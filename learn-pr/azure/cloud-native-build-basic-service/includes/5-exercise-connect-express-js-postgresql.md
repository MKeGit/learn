This exercise takes you through the process of creating and configuring an Express.js-based web service that provides access to Azure Database for PostgreSQL. 

In this exercise, you'll:

* Create a sample Node.js Express web app.
* Connect the Node.js Express web app to Azure Database for PostgreSQL.
* Configure Node.js Express routes for access to Azure Database for PostgreSQL.
* Validate the functionality of the Node.js Express web service.

## Prerequisites

To perform this exercise, you need:

* An Azure subscription.
* A Microsoft account or a Microsoft Entra account with the Global Administrator role in the Microsoft Entra tenant that's associated with the Azure subscription and with the Owner or Contributor role in the Azure subscription.
* To have completed the first exercise of this module. You'll use the Azure PostgreSQL database you created and configured in that exercise.

## Create a sample Node.js Express web app

You'll begin by creating a sample Node.js Express web app and apply to it incremental changes to implement the desired functionality.

1. If needed, from your computer, start a web browser, navigate to the [Azure portal](https://portal.azure.com/?azure-portal=true) and sign in to access the Azure subscription you used in the first exercise of this module.
1. In the Azure portal, start a Bash session within the **Cloud Shell** by selecting its icon in the toolbar next to the search text box.
1. Within the Bash session on the **Cloud Shell** pane, run the following commands to initialize a Node.js project in a new directory:

    ```azurecli
    mkdir -p cna-express && cd cna-express
    npm init -y
    ```

    > [!NOTE]
    > This creates a package.json, which contains all dependencies for the project.

1. Run the following command to add Express.js as the project's dependency:

    ```azurecli
    npm install express
    ```

1. Run the following command to create a file named **index.js** in the **cna-express** folder:

    ```azurecli
    touch ./index.js
    ```

1. Run the following command to open the newly created file **index.js** in the code editor:

    ```azurecli
    code index.js
    ```

1. Use the code editor to add to the **index.js** file the following content and save the file:

    ```javascript
    const express = require('express')
    const port = process.env.PORT || 8080
    const app = express()
    app.use(express.json());
    app.listen(port, () => console.log(`Sample app is listening on port ${port}!`))
    ```

    > [!NOTE]
    > To save a file in code editor, use the **ctrl+s** key combination. To close the editor pane, use the **ctrl+q** key combination or the menu on right side of the pane.

    The script invokes the app, configuring it to listen on TCP port **8080** and to accept the JSON-formatted body of HTTP requests. Starting with Express 4.16+, `app.use(express.json())` is required for JSON parsing.

    The use of **process.env.PORT** is specific to containers on Azure App Service, which sets the environment variable **PORT** in the Node.js container and sends the incoming requests to that port number. To receive the requests, your app should listen to that port using **process.env.PORT** (hence the use of `const port = process.env.PORT || 8080`).

    > [!NOTE]
    > You'll use Azure App Service in this exercise to facilitate testing of the Node.js Express functionality. You could also containerize the app and deploy it using Kubernetes and AKS as demonstrated in a previous module.

1. To allow the script to run, use the code editor to modify the autogenerated **package.json** file by replacing its existing content with the following content:

    ```javascript
    {
      "name": "node-express",
      "version": "1.0.0",
      "description": "Node.js express sample",
      "main": "index.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1",
        "start": "nodemon index.js"
      },
      "author": "",
      "license": "ISC",
      "dependencies": {
        "body-parser": "^1.19.0",
        "express": "^4.17.1",
        "http": "0.0.0",
        "morgan": "^1.10.0"
      },
      "devDependencies": {
        "nodemon": "^2.0.2"
      }
    }
    ```

## Connect the Node.js Express web app to Azure Database for PostgreSQL

Next, you'll configure your newly created Node.js Express web app to connect to the **cnainventory** database you created in the previous exercise of this module. To do this, you'll use Sequelize, which is a popular JavaScript library that provides the Object-Relation Mapper functionality, allowing you to map programmatic constructs into corresponding database schema.

1. From your computer, in the web browser window displaying the Azure portal, within the Bash session in the **Cloud Shell** pane, run the following command to add Sequelize and the corresponding PostgreSQL-specific packages into your project:

    ```azurecli
    npm i sequelize pg pg-hstore
    ```

1. To take advantage of these new capabilities, use the code editor to add the following line to the beginning of the **index.js** file:

    ```javascript
    const Sequelize = require('sequelize')
    ```

1. To establish a connection to the database, you need to add a connection string in the Sequalize-specific format to the **index.js** file following the line you added in the previous step. Replace the `<server_name>` placeholder with the name of the Azure Database for PostgreSQL server you provisioned in the previous exercise:

    ```javascript
    const sequelize = new Sequelize('postgres://Student%40<server_name>:Pa55w0rd1234@<server_name>.postgres.database.azure.com:5432/cnainventory')
    ```

    > [!NOTE]
    > The use of **%40** as the escape character between the username and the server name is specific to connection strings for Azure Database for PostgreSQL.

1. With the Sequelize package included as a requirement and the connection string configured, you can now establish a connection to the **cnainventory** database by adding the following code to the **index.js** file after the one you added in the previous step:

    ```javascript
    sequelize
    .authenticate()
    .then(() => {
       console.log('Connection has been established successfully.');
    })
    .catch(err => {
       console.error('Unable to connect to the database:', err);
    });
    ```

1. To facilitate operations on the **inventory** table you created in the previous exercise, you need to add to the **index.js file**, after the code you added in the previous step, a Sequelize-specific definition matching the table format, as below:

    ```javascript
    const Inventory = sequelize.define('inventory', {
       id: { type: Sequelize.INTEGER, allowNull: false, primaryKey: true },
       name: { type: Sequelize.STRING, allowNull: false },
       quantity: { type: Sequelize.INTEGER },
       date: { type: Sequelize.DATEONLY, defaultValue: Sequelize.NOW }
    }, {
       freezeTableName: true,
       timestamps: false
    });
    ```

    > [!NOTE]
    > The `timestamps: false` option is required to exclude from the scope of database operations a set of time-related columns, which, in this case, don't exist. The `freezeTableName: true` option disables the default behavior of Sequelize, which automatically transforms all model names into plural.

## Configure Node.js Express routes for access to Azure Database for PostgreSQL

Now you're ready to configure the routes that will provide read and write access to the **inventory** table in the **cnainventory** database hosted by the Azure Database for PostgreSQL server. For simplicity, you'll implement only two routes, but the procedure for configuring other routes would closely resemble the implementation you'll move through in this task. The first route will allow you to add individual inventory items by invoking an HTTP POST request with the inventory item values included in the request body, while the second route will process HTTP GET requests, returning an inventory item based on the value of its **id** attribute.

1. From your computer, in the web browser window displaying the Azure portal, within the Bash session on the **Cloud Shell** pane, use the code editor to add the following content to the end of the **index.js** file:

    ```javascript
    app.post('/inventory', async (req, res) => {
    try {
       const newItem = new Inventory(req.body)
       await newItem.save()
       res.json({ inventory: newItem })
    } catch(error) {
       console.error(error)
    }})
    ```

    > [!NOTE]
    > This part of the script manages the HTTP POST requests, adding a row to the **inventory** table that's populated with the values of **id**, **name**, and **quantity** attributes included in the request body. The value of the **date** attribute is calculated automatically based on the current date. The operation returns the newly added values as a confirmation of successful operation.

1. In the code editor, add the following content to the **index.js** file following the script you added in the previous step:

    ```javascript
    app.get('/inventory/:id', async (req, res) => {
       const id = req.params.id
       try {
          const inventory = await Inventory.findAll({
          attributes: ['id', 'name', 'quantity', 'date'],
          where: {
             id: id
          }})
          res.json({ inventory })
       } catch(error) {
           console.error(error)
    }})
    ```

    > [!NOTE]
    > This part of the script manages the HTTP GET requests, returning the values of **id**, **name**, **quantity**, and **date** attributes based on the value of **id** included in the request.

    > [!NOTE]
    > This yields a fully functional script in the following format (if you intend to copy this code, make sure to replace each occurence of the `cnapostgresqldb` name with the name of your PostgreSQL server):
    >
    ```javascript
    const Sequelize = require('sequelize')
    const sequelize = new Sequelize('postgres://Student%40postgresql-ek.postgres.database.azure.com:Pa55w0rd1234@postgresql-ek.postgres.database.azure.com:5432/cnainventory')
    sequelize
    .authenticate()
    .then(() => {
       console.log('Connection has been established successfully.');
    })
    .catch(err => {
       console.error('Unable to connect to the database:', err);
    });
    const Inventory = sequelize.define('inventory', {
       id: { type: Sequelize.INTEGER, allowNull: false, primaryKey: true },
       name: { type: Sequelize.STRING, allowNull: false },
       quantity: { type: Sequelize.INTEGER },
       date: { type: Sequelize.DATEONLY, defaultValue: Sequelize.NOW }
    }, {
       freezeTableName: true,
       timestamps: false
    });
    const express = require('express')
    const port = process.env.PORT || 8080
    const app = express()
    app.use(express.json());
    app.listen(port, () => console.log(`Sample app is listening on port ${port}!`))
    app.post('/inventory', async (req, res) => {
    try {
       const newItem = new Inventory(req.body)
       await newItem.save()
       res.json({ inventory: newItem })
    } catch(error) {
       console.error(error)
    }})
    app.get('/inventory/:id', async (req, res) => {
       const id = req.params.id
       try {
      const inventory = await Inventory.findAll({
          attributes: ['id', 'name', 'quantity', 'date'],
          where: {
             id: id
          }})
          res.json({ inventory })
       } catch(error) {
           console.error(error)
    }})
    ```

## Validate the functionality of the Node.js Express web service

You're finally ready to test the functionality of your web service. You could containerize it at this point, but for the sake of simplicity, you'll deploy it to an Azure App Service. This will provide a quick way to validate its functionality and ensure that containerizing it is a viable option.

1. Within the web browser window displaying the Azure portal, from the Bash session on the **Cloud Shell** pane, run the following commands to create a resource group that will host the Azure web app, into which you'll deploy the Node.js Express app:

    ```azurecli
    RG1NAME=postgresql-db-RG
    LOCATION=$(az group show --resource-group $RG1NAME --query location --output tsv)
    RG2NAME=cna-express-RG
    az group create --name $RG2NAME --location $LOCATION
    ```

1. Run the following commands to create a Free-tier Azure App Service plan that will host the new Azure web app:

    ```azurecli
    SPNAME=express-sp
    az appservice plan create --name $SPNAME --resource-group $RG2NAME --sku F1 --is-linux
    ```

1. Run the following commands to create the new Node.js-based Azure web app and deploy the code into it:

    ```azurecli
    WEBAPPNAME=express$RANDOM$RANDOM
    az webapp create --name $WEBAPPNAME --resource-group $RG2NAME --plan $SPNAME --runtime "NODE|12-lts"

    cd ~/cna-express
    git config --global user.email "user1@adatum.com"
    git config --global user.name "Adatum User1"
    git init
    git add -A
    git commit -m "Initial Commit"

    DEPLOYMENTUSER=m03User$RANDOM
    DEPLOYMENTPASS=m03Pass$RANDOM$RANDOM
    az webapp deployment user set --user-name $DEPLOYMENTUSER --password $DEPLOYMENTPASS

    echo $DEPLOYMENTUSER
    echo $DEPLOYMENTPASS

    RG2NAME=cna-express-RG
    WEBAPPNAME=$(az webapp list --resource-group $RG2NAME --query "[0].name" --output tsv)
    DEPLOYMENTURL=$(az webapp deployment source config-local-git --name $WEBAPPNAME --resource-group $RG2NAME --output tsv)

    git remote add azure $DEPLOYMENTURL

    git checkout -b master
    git commit -a -m "test"
    git push --set-upstream azure master
    ```

    > [!NOTE]
    > When prompted for a password, type the password displayed following the `echo $DEPLOYMENTPASS` command.  

    > [!NOTE]
    > Ignore messages stating that the master branch already exists or that nothing was committed. 

1. Run the following commands to validate the POST HTTP routing of the Node.js Express app:

    ```azurecli
    RG2NAME=cna-express-RG
    WEBAPPNAME=$(az webapp list --resource-group $RG2NAME --query "[0].name" --output tsv)
    curl --header "Content-Type: application/json" \
    --request POST \
    --data '{"id":3,"name":"ice cream","quantity":50}' \
    http://$WEBAPPNAME.azurewebsites.net/inventory
    ```
    
    > [!NOTE]
    > The command should return the values of the entries of the newly added table row, including the autogenerated date. It may take one to two minutes for the command to return the output values.

1. To validate the GET HTTP routing of the Node.js Express app, in the web browser that displays the **Cloud Shell** pane, open another tab, navigate to the [Azure portal](https://portal.azure.com?azure-portal=true), and then use the **Search resources, services, and docs** text box to search for the App Service web app you deployed. Navigate to its **Overview** blade, identify the value of **URL** property, append the string `/inventory/3` to that URL value, open another tab in the same browser window, and navigate to the newly constructed URL string to display the corresponding webpage.

    > [!NOTE]
    > The page should display the properties of the item you added to the **inventory** table of the **cnainventory** database in the previous step.

## Results

Congratulations! You've completed the second exercise of this module. In this exercise, you created and configured an Express.js-based web service that provides access to Azure Database for PostgreSQL. The resources you deployed in this exercise will be required to successfully complete the next exercise in this module.
